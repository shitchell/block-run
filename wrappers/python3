#!/usr/bin/env python3
"""
Python wrapper for block-run.
Executes blocks with exec() in a shared globals dict - state persists naturally.

This script is invoked BY the target Python interpreter, so it runs in the
correct version automatically.

Usage: python3 this-wrapper -- block1 block2 ...
"""
from __future__ import print_function
import sys
import traceback

# ANSI colors
CYAN = '\033[36m'
RED = '\033[31m'
DIM = '\033[2m'
RESET = '\033[0m'

def highlight_python(code):
    """Syntax highlight if pygments available, otherwise return as-is."""
    try:
        from pygments import highlight
        from pygments.lexers import PythonLexer
        from pygments.formatters import TerminalFormatter
        return highlight(code, PythonLexer(), TerminalFormatter()).rstrip()
    except ImportError:
        return code

def separator():
    return DIM + 'â”€' * 41 + RESET

def is_comment_only(block):
    """Check if block contains only comments and whitespace."""
    for line in block.split('\n'):
        stripped = line.strip()
        if stripped and not stripped.startswith('#'):
            return False
    return True

def main():
    # Parse args - skip everything before '--'
    args = sys.argv[1:]
    if '--' in args:
        args = args[args.index('--') + 1:]

    if not args:
        print("error: no blocks provided", file=sys.stderr)
        sys.exit(1)

    # Shared globals dict - state persists across all blocks
    shared_globals = {
        "__name__": "__main__",
        "__builtins__": __builtins__,
    }

    for i, block in enumerate(args, 1):
        # Handle comment-only blocks
        if is_comment_only(block):
            print(f"{CYAN}# Block {i} (comments only){RESET}")
            print(highlight_python(block))
            print(separator())
            print()
            continue

        # Show block header and code
        print(f"{CYAN}# Block {i}{RESET}")
        print(highlight_python(block))
        print(separator())

        # Execute in shared context
        exit_code = 0
        try:
            compiled = compile(block, f"<block {i}>", "exec")
            exec(compiled, shared_globals)
        except SystemExit as e:
            # Allow sys.exit() but capture the code
            exit_code = e.code if isinstance(e.code, int) else 1
        except Exception:
            traceback.print_exc()
            exit_code = 1

        if exit_code != 0:
            print(f"{RED}(exit code: {exit_code}){RESET}")

        print()

if __name__ == "__main__":
    main()
