#!/usr/bin/env bash
set -euo pipefail

# Bash wrapper for block-run
# Executes blocks in the current shell context - state persists naturally
# NO REPLAY - each block runs once, variables/functions persist
#
# This script is invoked BY the target bash interpreter, so it runs in the
# correct version automatically.
#
# Usage: bash this-wrapper -- block1 block2 ...

BLOCKS=()

# Colors
CYAN=$'\e[36m'
RED=$'\e[31m'
DIM=$'\e[2m'
RESET=$'\e[0m'

usage() {
    cat <<EOF
Usage: bash $(basename "$0") -- <block1> [block2] ...

Bash wrapper for block-run. Executes bash blocks sequentially
in the current shell context. Variables and functions persist
between blocks naturally - no replay needed.

This script is not meant to be called directly.
EOF
    exit "${1:-0}"
}

die() {
    echo "error: $*" >&2
    exit 1
}

# Syntax highlight bash if pygmentize is available
highlight_bash() {
    if command -v pygmentize &>/dev/null; then
        pygmentize -l bash
    else
        cat
    fi
}

# Print a separator
separator() {
    echo "${DIM}─────────────────────────────────────────${RESET}"
}

# Check if block contains only comments and whitespace
is_comment_only() {
    local block="$1"
    local stripped
    stripped=$(echo "$block" | grep -v '^[[:space:]]*#' | grep -v '^[[:space:]]*$' || true)
    [[ -z "$stripped" ]]
}

main() {
    # Parse arguments - skip everything before '--'
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                usage 0
                ;;
            --)
                shift
                BLOCKS=("$@")
                break
                ;;
            *)
                # Skip unknown args before --
                shift
                ;;
        esac
    done

    [[ ${#BLOCKS[@]} -gt 0 ]] || die "no blocks provided"

    local block_num=0

    for block in "${BLOCKS[@]}"; do
        ((++block_num))

        # Handle comment-only blocks
        if is_comment_only "$block"; then
            echo "${CYAN}# Block $block_num (comments only)${RESET}"
            echo "$block" | highlight_bash
            separator
            echo
            continue
        fi

        # Show block header and highlighted code
        echo "${CYAN}# Block $block_num${RESET}"
        echo "$block" | highlight_bash
        separator

        # Execute in current shell context - state persists naturally!
        # Temporarily disable errexit so we can capture the exit code
        set +e
        eval "$block"
        local exit_code=$?
        set -e

        if [[ $exit_code -ne 0 ]]; then
            echo "${RED}(exit code: $exit_code)${RESET}"
        fi

        echo
    done
}

main "$@"
