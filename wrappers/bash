#!/usr/bin/env bash
set -euo pipefail

# Bash wrapper for block-run
# Executes blocks in the current shell context - state persists naturally
# NO REPLAY - each block runs once, variables/functions persist

BINARY=""
BLOCKS=()

# Colors
CYAN=$'\e[36m'
RED=$'\e[31m'
DIM=$'\e[2m'
RESET=$'\e[0m'

usage() {
    cat <<EOF
Usage: $(basename "$0") --binary <path> -- <block1> [block2] ...

Bash wrapper for block-run. Executes bash blocks sequentially
in the current shell context. Variables and functions persist
between blocks naturally - no replay needed.

This script is not meant to be called directly.
EOF
    exit "${1:-0}"
}

die() {
    echo "error: $*" >&2
    exit 1
}

# Syntax highlight bash if pygmentize is available
highlight_bash() {
    if command -v pygmentize &>/dev/null; then
        pygmentize -l bash
    else
        cat
    fi
}

# Print a separator
separator() {
    echo "${DIM}─────────────────────────────────────────${RESET}"
}

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --binary)
                BINARY="$2"
                shift 2
                ;;
            --help|-h)
                usage 0
                ;;
            --)
                shift
                BLOCKS=("$@")
                break
                ;;
            *)
                die "unexpected argument: $1"
                ;;
        esac
    done

    [[ -n "$BINARY" ]] || die "--binary is required"
    [[ ${#BLOCKS[@]} -gt 0 ]] || die "no blocks provided"

    local block_num=0

    for block in "${BLOCKS[@]}"; do
        ((++block_num))

        # Skip empty blocks or comment-only blocks
        local stripped
        stripped=$(echo "$block" | grep -v '^[[:space:]]*#' | grep -v '^[[:space:]]*$' || true)
        if [[ -z "$stripped" ]]; then
            # Still show the comments
            echo "${CYAN}# Block $block_num (comments only)${RESET}"
            echo "$block" | highlight_bash
            separator
            echo
            continue
        fi

        # Show block header and highlighted code
        echo "${CYAN}# Block $block_num${RESET}"
        echo "$block" | highlight_bash
        separator

        # Execute in current shell context - state persists naturally!
        # Temporarily disable errexit so we can capture the exit code
        set +e
        eval "$block"
        local exit_code=$?
        set -e

        if [[ $exit_code -ne 0 ]]; then
            echo "${RED}(exit code: $exit_code)${RESET}"
        fi

        echo
    done
}

main "$@"
